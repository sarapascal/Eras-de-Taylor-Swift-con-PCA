---
title: "ERAS PCA"
author: "Sara Vidal"
date: "2025-12-06"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Vamos a realizar un An√°lisis de componentes principales en base a datos del Eras Tour de Taylor Swift. Utilizaremos una base de Kaggle que ya hab√≠amos utilizado antes, pero con m√°s profundidad.

# Instalamos las librer√≠as que vamos a utilizar
library(tidyverse)
library(stringr)
library(ggplot2)
library(scales)
library(ggrepel)


# Cargamos la base de datos
df <- readr::read_csv("~/Desktop/Datos/ERAS PCA/ERAS PCA/era_tour_setlist.csv")


# Con los nombres de la canciones definiremos las eras, haciendo un etiquetado de cada fila de la base para indicar a qu√© ‚Äúera‚Äù (√°lbum) pertenece cada track. Esto nos va a permitir, agrupar y comparar el indicador PCA por era del tour m√°s adelante.

df <- df %>%
  mutate(era = case_when(
    # Lover
    track_name %in% c("Miss Americana & The Heartbreak Prince","Cruel Summer","The Man", "You Need To Calm Down","Lover","The Archer") ~ "Lover",
    # Fearless (Taylor's Version)
    str_detect(track_name, regex("^Fearless", ignore_case = TRUE)) |
      str_detect(track_name, "You Belong With Me") |
      str_detect(track_name, "Love Story") ~ "Fearless",
    # Red (Taylor's Version)
    track_name %in% c("22 (Taylor's Version)",
                      "We Are Never Ever Getting Back Together (Taylor's Version)",
                      "I Knew You Were Trouble (Taylor's Version)",
                      "All Too Well (10 Minute Version) (Taylor's Version) (From The Vault)") ~ "Red",
    # Reputation
    track_name %in% c("...Ready For It?","Delicate","Don‚Äôt Blame Me","Look What You Made Me Do") ~ "Reputation",
    # folklore
    track_name %in% c("cardigan","betty","my tears ricochet", "august", "illicit affairs") ~ "folklore",
    # evermore
    track_name %in% c("champagne problems","marjorie","willow") ~ "evermore",
    # 1989 (Taylor's Version)
    track_name %in% c("Style (Taylor's Version)","Blank Space (Taylor's Version)",
                      "Shake It Off (Taylor's Version)","Wildest Dreams (Taylor's Version)",
                      "Bad Blood (Taylor's Version)") ~ "1989",
    # Speak Now (Taylor's Version)
    str_detect(track_name, "Enchanted") ~ "Speak Now",
    # The Tortured Poets Department (TTPD)
    track_name %in% c("But Daddy I Love Him","So High School","Who‚Äôs Afraid of Little Old Me?",
                      "Down Bad","Fortnight (feat. Post Malone)",
                      "The Smallest Man Who Ever Lived","I Can Do It With a Broken Heart") ~ "TTPD",
    # Midnights
    track_name %in% c("Lavender Haze","Anti-Hero","Midnight Rain","Vigilante Shit",
                      "Bejeweled","Mastermind","Karma") ~ "Midnights",
    TRUE ~ NA_character_
    ))

# Revisando... para ver si todo est√° perfectly fine
## ¬øCu√°les son las canciones sin era? (deber√≠a idealmente ser 0)
df %>% filter(is.na(era)) %>% distinct(track_name)

## Conteo por era
df %>% count(era, sort = TRUE)


# Seleccionaremos las variables y escala para que funcione nuestro PCA. 
## Vamos a seleccionar las variables num√©ricas que van a entrar al PCA (en formato num√©rico, sin NA), despu√©s filtraremos outliers obvios (por ejemplo, duraciones demasiado cortas/largas que no son representativas del set) y vamos a estandarizar/escalar cada variable para que todas tengan media 0 y desv√≠o est√°ndar 1.

##Esta base tiene variables ac√∫sticas, as√≠ que utilizaremos esa informaci√≥n y tambi√©n otras como duraci√≥n y popularidad.
## En este caso, haremos la escala sin reducir por duraci√≥n porque a pesar de que "All too well" se sale del rango normal o promedio es una parte importante del show. Veremos como se refleja esto despu√©s...
## Escalamos con mutate(across(..., scale)), lo que asegura que todas las variables tengan media 0 y sd 1.

variables <- c("danceability","energy","valence","tempo","loudness",
          "speechiness","acousticness","instrumentalness","liveness",
          "duration_ms","popularity")

df_variables <- df %>%
  drop_na(all_of(variables)) %>%
  mutate(across(all_of(variables), scale))

#Revisando...
summary(df[variables])        # antes
summary(df_variables[variables])  # despu√©s (medias ~0, sd ~1)


# Comenzamos la matriz para PCA (ya escalada en df_variables)
X <- df_variables %>% dplyr::select(dplyr::all_of(variables)) %>% as.matrix()

# Ejecutando PCA
## Como las variables ya est√°n escaladas (z-score), no centramos/escalamos de nuevo
pca <- prcomp(X, center = FALSE, scale. = FALSE)

## Resumen r√°pido del PCA (varianza explicada por cada componente)
summary(pca)


# Proporci√≥n de varianza explicada por cada PC
var_exp <- pca$sdev^2 / sum(pca$sdev^2)

# Scree plot base R
plot(var_exp, type = "b", pch = 19,
     xlab = "Componente principal",
     ylab = "Proporci√≥n de varianza explicada",
     main = "Scree Plot (PCA)")
abline(h = 0.1, col = "gray70", lty = 2) 

# Versi√≥n ggplot 
library(ggplot2)
df_varpc <- tibble::tibble(PC = paste0("PC", seq_along(var_exp)),
                         VarExp = var_exp)

ggplot(df_varpc, aes(x = PC, y = VarExp, group = 1)) +
  geom_point(size = 2) + geom_line() +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  labs(title = "Scree Plot (PCA)", x = "Componente principal", y = "Varianza explicada") +
  theme_minimal()

# Varianza acumulada
acum_var <- cumsum(var_exp)

# Tabla r√°pida en consola
data.frame(PC = paste0("PC", seq_along(var_exp)),
           VarExp = round(var_exp, 4),
           AcumVar = round(acum_var, 4))

# Cargas (qu√© pesa en cada componente)
loadings <- pca$rotation

# Ver las cargas de los 3 primeros PCs (redondeadas)
print(round(loadings[, 1:3], 3))

# Variables que m√°s pesan en PC1 (para nombrarlo)
sort(loadings[,1], decreasing = TRUE)

# Variables que m√°s pesan en PC2
sort(loadings[,2], decreasing = TRUE)

#¬øQu√© son estos resultados?
##Si vemos cargas altas positivas en energy, loudness, tempo y negativas en acousticness ‚Üí PC1 ‚âà ‚ÄúIntensidad/Energ√≠a‚Äù. Y Si danceability y valence cargan alto en PC2 ‚Üí PC2 ‚âà ‚ÄúBailabilidad/Positividad‚Äù. Speechiness e instrumentalness suelen matizar (m√°s hablado vs. m√°s instrumental).

# Dej√©mosolo en una tablita
knitr::kable(round(loadings[,1:3], 3), caption = "Cargas de las variables en PC1‚ÄìPC3")

# Scores (coordenadas de cada canci√≥n en los PCs)
scores <- as.data.frame(pca$x) %>% dplyr::select(PC1, PC2, PC3)

# Unimos los scores al df (para tener track_name y metadatos)
df_scores <- df_variables %>%
  dplyr::bind_cols(scores) %>%
  dplyr::rename(indicador_pc1 = PC1, indicador_pc2 = PC2)

# Normalizamos el indicador principal (PC1) a escala 0‚Äì100 (para comunicarlo mejor)
rng <- range(df_scores$indicador_pc1, na.rm = TRUE)
df_scores <- df_scores %>%
  dplyr::mutate(indicador_0_100 = 100 * (indicador_pc1 - rng[1]) / (rng[2] - rng[1]))

## Ya que incluimos popularity dentro de las variables del PCA, el indicador mezcla perfil ac√∫stico con recepci√≥n del p√∫blico.

# Top 10 canciones (mayor intensidad/energ√≠a seg√∫n PC1)
top10 <- df_scores %>%
  dplyr::arrange(dplyr::desc(indicador_0_100)) %>%
  dplyr::select(track_name, indicador_0_100) %>%
  head(10)

knitr::kable(top10, caption = "Top 10 canciones por indicador (PC1 ‚Üí 0‚Äì100)")

### El PC1 explica r scales::percent(var_exp[1]) y el PC2 r scales::percent(var_exp[2]) de la varianza total; juntos, los dos primeros explican r scales::percent(sum(var_exp[1:2])).

# Promedio del indicador por era
indicador_era <- df_scores %>%
  dplyr::filter(!is.na(era)) %>%
  dplyr::group_by(era) %>%
  dplyr::summarise(indicador_era = mean(indicador_0_100),
                   n_canciones = n(),
                   .groups = "drop") %>%
  dplyr::arrange(dplyr::desc(indicador_era))

knitr::kable(indicador_era, caption = "Indicador promedio por era (PC1 ‚Üí 0‚Äì100)")

# Barras por era
library(ggplot2)
ggplot(indicador_era, aes(x = reorder(era, indicador_era), y = indicador_era)) +
  geom_col(fill = "#7B68EE") +
  coord_flip() +
  labs(title = "Indicador PCA (PC1) promedio por Era",
       x = "Era", y = "Indicador 0‚Äì100") +
  theme_minimal()

# Biplot base: PCs y vectores de variables (diagn√≥stico r√°pido)
biplot(pca, xlabs = rep(".", nrow(df_variables)))
title("Biplot PC1 vs PC2")

### PC1 es alto en r paste(names(sort(loadings[,1], decreasing = TRUE)[1:3]), collapse = ", ") y bajo en r names(sort(loadings[,1], decreasing = FALSE)[1]); y lo interpretamos como ‚ÄòIntensidad/Energ√≠a‚Äô. El PC2 es alto en r paste(names(sort(loadings[,2], decreasing = TRUE)[1:3]), collapse = ", "), interpretado como ‚ÄòBailabilidad/Positividad‚Äô.‚Äù

### Definimos el indicador principal como el score en PC1, normalizado a 0‚Äì100 para facilitar la lectura. Quedando el ranking de canciones y agregaci√≥n por era.

### Las variables de entrada se estandarizaron (media 0, sd 1). No se filtr√≥ duraci√≥n (se mantuvo ‚ÄòAll Too Well (10 Minute Version)‚Äô por su relevancia en el show). 



# --- Heatmap de loadings PC1‚ÄìPC3 ---
## Tomamos las cargas y pasamos a formato largo
loadings <- pca$rotation
loadings_df <- loadings[, 1:3] %>%            # selecciona PC1, PC2, PC3
  as.data.frame() %>%
  rownames_to_column(var = "variable") %>%
  pivot_longer(cols = starts_with("PC"),
               names_to = "PC",
               values_to = "loading")

# Ordenamos variables por la magnitud de su contribuci√≥n en PC1 (para visualizarlas)
vars_order <- loadings_df %>%
  filter(PC == "PC1") %>%
  arrange(desc(loading)) %>%
  pull(variable)

loadings_df <- loadings_df %>%
  mutate(variable = factor(variable, levels = vars_order),
         PC = factor(PC, levels = c("PC1", "PC2", "PC3")))
         

# Heatmap
ggplot(loadings_df, aes(x = PC, y = variable, fill = loading)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(low = "#1f77b4", mid = "white", high = "#d62728",
                       midpoint = 0, limits = c(min(loadings_df$loading), max(loadings_df$loading)),
                       name = "Carga") +
  labs(title = "Heatmap de cargas (loadings) en PC1‚ÄìPC3",
       x = "Componente principal", y = "Variable") +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 10))
  

# Seleccionamos top N por magnitud en PC1 (ajusta N si quieres menos/m√°s etiquetas)
N <- 12
df_scores <- df_scores %>%
  mutate(abs_pc1 = abs(indicador_pc1))

df_labels <- df_scores %>%
  arrange(desc(abs_pc1)) %>%
  slice(1:N)

ggplot(df_scores, aes(x = indicador_pc1, y = indicador_pc2)) +
  geom_hline(yintercept = 0, color = "gray80") +
  geom_vline(xintercept = 0, color = "gray80") +
  geom_point(alpha = 0.6, color = "#7B68EE", size = 2) +
  geom_point(data = df_labels, color = "#FF7F50", size = 2.5) +
  geom_text_repel(data = df_labels,
                  aes(label = track_name),
                  size = 3.2,
                  box.padding = 0.4,
                  point.padding = 0.2,
                  max.overlaps = 100,
                  seed = 123,
                  min.segment.length = 0) +
  labs(title = "Mapa PC1 vs PC2 ‚Äî canciones del Eras Tour",
       x = "PC1 (Intensidad/Energ√≠a, seg√∫n cargas)",
       y = "PC2 (Bailabilidad/Positividad, seg√∫n cargas)") +
  theme_minimal()


#üìÑ Conclusiones

## Resumen del PCA:
### El PC1 explica r scales::percent(var_exp[1]) y el PC2 r scales::percent(var_exp[2]) de la varianza; en conjunto suman r scales::percent(sum(var_exp[1:2])).
PC1 ‚Äî Intensidad/Energ√≠a: altas cargas en energy, loudness, tempo y bajas en acousticness.
PC2 ‚Äî Bailabilidad/Positividad: dominado por danceability y valence.
PC3 ‚Äî Textura/Ac√∫stico‚ÄìVocal (o el nombre que definiste): matizado por speechiness, instrumentalness, liveness.

### Indicador compuesto:
Definimos el indicador principal como el score en PC1, normalizado a 0‚Äì100. Presentamos el ranking de canciones y la agregaci√≥n por era.

### Decisiones metodol√≥gicas:
(i) Est√°ndar z‚Äìscore en features; (ii) No se filtr√≥ la duraci√≥n por la relevancia de ‚ÄúAll Too Well (10 Minute Version)‚Äù; (iii) La inclusi√≥n/exclusi√≥n de popularity dentro del PCA se documenta.

### Limitaciones:
Los cambios de setlist y versiones (Taylor‚Äôs Version) pueden afectar comparabilidad si se ampl√≠a la base.




# BLOQUE FINAL ‚Äî Nombres de PCs, exportaciones, estilo Eras, biplot estilizado y guardado de figuras

## Nombres interpretativos de componentes
pc_names <- c(
  PC1 = "Intensidad/Energ√≠a",
  PC2 = "Bailabilidad/Positividad",
  PC3 = "Textura/Ac√∫stico‚ÄìVocal"
)

# Paleta y estilo Eras Tour (lavanda/rosa/morado)
eras_colors <- list(
  lavanda = "#CDB4DB",
  rosa    = "#FF69B4",
  morado  = "#6A0572",
  negro   = "#1F1F1F",
  gris    = "#9E9E9E"
)

# Tipograf√≠a: Soulmate de Lover
eras_theme <- function(base_family = "soulmate") {
  theme_minimal(base_family = base_family) +
    theme(
      plot.title      = element_text(face = "bold", size = 16, color = eras_colors$morado),
      plot.subtitle   = element_text(size = 11, color = eras_colors$gris),
      axis.title.x    = element_text(size = 12),
      axis.title.y    = element_text(size = 12),
      axis.text       = element_text(color = eras_colors$negro),
      panel.grid.minor= element_blank()
    )
}

# Scree Plot (ggplot) con estilo Eras
df_varpc <- tibble::tibble(PC = paste0("PC", seq_along(var_exp)),
                           VarExp = var_exp)
df_varpc$PC <- factor(df_varpc$PC, levels = df_varpc$PC)

p_scree <- ggplot(df_varpc, aes(x = PC, y = VarExp, group = 1)) +
  geom_point(size = 2, color = eras_colors$morado) +
  geom_line(color = eras_colors$morado) +
  scale_y_continuous(labels = percent_format(accuracy = 1)) +
  labs(title = "Scree Plot (PCA)",
       subtitle = "Proporci√≥n de varianza explicada por componente",
       x = "Componente principal", y = "Varianza explicada") +
  eras_theme()

# 5) Heatmap de cargas (PC1‚ÄìPC3) con estilo Eras y subt√≠tulo con nombres
loadings <- pca$rotation
loadings_df <- loadings[, 1:3] %>%
  as.data.frame() %>%
  tibble::rownames_to_column(var = "variable") %>%
  tidyr::pivot_longer(cols = dplyr::starts_with("PC"),
                      names_to = "PC", values_to = "loading")

vars_order <- loadings_df %>%
  dplyr::filter(PC == "PC1") %>%
  dplyr::arrange(dplyr::desc(loading)) %>%
  dplyr::pull(variable)

loadings_df <- loadings_df %>%
  dplyr::mutate(variable = factor(variable, levels = vars_order),
                PC = factor(PC, levels = c("PC1", "PC2", "PC3")))

p_heat <- ggplot(loadings_df, aes(x = PC, y = variable, fill = loading)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(
    low = eras_colors$lavanda, mid = "white", high = eras_colors$morado,
    midpoint = 0, name = "Carga"
  ) +
  labs(
    title = "Cargas por componente (PC1‚ÄìPC3)",
    subtitle = paste("PC1:", pc_names["PC1"], "| PC2:", pc_names["PC2"], "| PC3:", pc_names["PC3"]),
    x = "Componente", y = "Variable"
  ) +
  eras_theme()

# 6) Scatter PC1 vs PC2 con etiquetas (ggrepel) y ejes con nombres
#    (Aseg√∫rate de tener df_scores con indicador_pc1, indicador_pc2, track_name)
if (!requireNamespace("ggrepel", quietly = TRUE)) {
  install.packages("ggrepel")
}
library(ggrepel)

N <- 12
df_scores <- df_scores %>% dplyr::mutate(abs_pc1 = abs(indicador_pc1))
df_labels <- df_scores %>% dplyr::arrange(dplyr::desc(abs_pc1)) %>% dplyr::slice(1:N)

p_scatter <- ggplot(df_scores, aes(x = indicador_pc1, y = indicador_pc2)) +
  geom_hline(yintercept = 0, color = eras_colors$gris) +
  geom_vline(xintercept = 0, color = eras_colors$gris) +
  geom_point(alpha = 0.6, color = eras_colors$rosa, size = 2) +
  geom_point(data = df_labels, color = eras_colors$morado, size = 3) +
  geom_text_repel(
    data = df_labels, aes(label = track_name),
    size = 3.2, box.padding = 0.4, point.padding = 0.2,
    max.overlaps = Inf, seed = 123, min.segment.length = 0,
    color = eras_colors$negro
  ) +
  labs(
    title = "Mapa PC1 vs PC2 ‚Äî canciones del Eras Tour",
    subtitle = paste("Ejes:", pc_names["PC1"], "y", pc_names["PC2"]),
    x = paste0("PC1 ‚Äî ", pc_names["PC1"]),
    y = paste0("PC2 ‚Äî ", pc_names["PC2"])
  ) +
  eras_theme()

# 7) Barras por era (si existe 'indicador_era') con estilo Eras
p_era <- NULL
if (exists("indicador_era")) {
  p_era <- ggplot(indicador_era, aes(x = reorder(era, indicador_era), y = indicador_era)) +
    geom_col(fill = eras_colors$lavanda) +
    coord_flip() +
    labs(
      title = "Indicador PCA (PC1) promedio por Era",
      subtitle = paste("PC1:", pc_names["PC1"]),
      x = "Era", y = "Indicador 0‚Äì100"
    ) +
    eras_theme()
}

# 8) Biplot estilizado con vectores y nombres (factoextra)
#    Instala/ carga factoextra
if (!requireNamespace("factoextra", quietly = TRUE)) {
  install.packages("factoextra")
}
library(factoextra)

# Nota: fviz_pca_biplot utiliza internamente los loadings y scores de 'pca'
p_biplot <- fviz_pca_biplot(
  pca, repel = TRUE,
  col.var = eras_colors$morado, col.ind = eras_colors$rosa,
  label = "var", # etiqueta variables (vectores); cambiar a "all" para incluir puntos
  geom.ind = "point", pointsize = 2,
  title = paste("Biplot PCA ‚Äî", pc_names["PC1"], "vs", pc_names["PC2"])
) + eras_theme()

# 9) Guardar figuras en 'report/'
if (!dir.exists("report")) dir.create("report", recursive = TRUE)

ggsave("report/scree_plot_pca.png", p_scree, width = 8, height = 4.5, dpi = 300)
ggsave("report/heatmap_loadings_pc1_pc3.png", p_heat, width = 8, height = 5.5, dpi = 300)
ggsave("report/scatter_pc1_pc2_top_labels.png", p_scatter, width = 8, height = 5.5, dpi = 300)
if (!is.null(p_era)) {
  ggsave("report/indicador_por_era.png", p_era, width = 7.5, height = 5, dpi = 300)
}
ggsave("report/biplot_pca.png", p_biplot, width = 7.5, height = 5.5, dpi = 300)

# 10) Tabla resumen con nombres y varianza (para el informe)
pc_table <- tibble::tibble(
  PC          = names(pc_names),
  Nombre      = unname(pc_names),
  Varianza    = round(var_exp[1:3], 3),
  Varianza_pct= percent(var_exp[1:3])
)
knitr::kable(pc_table, caption = "Nombres e importancia de los primeros tres componentes")


