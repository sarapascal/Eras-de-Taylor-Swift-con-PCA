---
title: "ERAS PCA"
author: "Sara Vidal"
date: "2025-12-06"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Vamos a realizar un An√°lisis de componentes principales en base a datos del Eras Tour de Taylor Swift. Utilizaremos una base de Kaggle que ya hab√≠amos utilizado antes, pero con m√°s profundidad.

# Trabajo previo
## Instalamos las librer√≠as que vamos a utilizar
library(tidyverse)
library(stringr)
library(ggplot2)
library(scales)
library(ggrepel)
library(dplyr)


## Cargamos la base de datos
df <- readr::read_csv("~/Desktop/Datos/ERAS PCA/ERAS PCA/era_tour_setlist.csv")

## Agregamos la l√≠nea gr√°fica que queremos utilizar
swifty_colors <- list(
  lavanda = "#CDB4DB",
  morado  = "#6A0572",
  rosa    = "#FF69B4",
  negro   = "#1F1F1F",
  gris    = "#9E9E9E",
  crema   = "#F7F2F7"
)

# Paletas por era (ajustadas seg√∫n tu pedido)
swifty_era_pal <- list(
  Lover      = c("#FFADBC", "#FF7AB8", "#FFC6D9"),
  Reputation = c("#1F1F1F", "#4B4B4B", "#9E9E9E"),
  Red        = c("#E3252B", "#EF6A6A", "#F3A5A5"),
  "1989"     = c("#76BEE1", "#9FD4EE", "#CFEAF8"),
  Midnights  = c("#0B1D4D", "#364F6B", "#6C7B95"),
  Folklore   = c("#CDC9C1", "#CDC9C2", "#CDC9C3"),
  Evermore   = c("#C5AC90", "#C5AC91", "#C5AC93"),
  TTPD       = c("#7B7D7D", "#B0B3B5", "#DEE1E3"),
  Fearless   = c("#DAA520", "#E1B000", "#FFD700"),
  "Speak Now"= c("#9B59B6", "#8E44AD", "#C39BD3")
)

# Tema
theme_swifty <- function(base_family = "serif", base_size = 12) {
  ggplot2::theme_minimal(base_family = base_family, base_size = base_size) +
    ggplot2::theme(
      plot.background   = ggplot2::element_rect(fill = swifty_colors$crema, color = NA),
      panel.grid.minor  = ggplot2::element_blank(),
      panel.grid.major  = ggplot2::element_line(color = swifty_colors$lavanda, linewidth = 0.15),
      plot.title        = ggplot2::element_text(color = swifty_colors$morado, face = "bold", size = base_size + 3),
      plot.subtitle     = ggplot2::element_text(color = swifty_colors$gris, size = base_size),
      axis.title.x      = ggplot2::element_text(color = swifty_colors$negro, face = "bold"),
      axis.title.y      = ggplot2::element_text(color = swifty_colors$negro, face = "bold"),
      axis.text         = ggplot2::element_text(color = swifty_colors$negro),
      legend.position   = "right",
      legend.title      = ggplot2::element_text(face = "bold", color = swifty_colors$morado)
    )
}
eras_theme <- theme_swifty

# Tema Swifty con 'family' expl√≠cito en t√≠tulos y subt√≠tulos
theme_swifty <- function(base_family = "serif", base_size = 12) {
  ggplot2::theme_minimal(base_family = base_family, base_size = base_size) +
    ggplot2::theme(
      plot.background   = ggplot2::element_rect(fill = swifty_colors$crema, color = NA),
      panel.grid.minor  = ggplot2::element_blank(),
      panel.grid.major  = ggplot2::element_line(color = swifty_colors$lavanda, linewidth = 0.15),
      plot.title        = ggplot2::element_text(
        family = base_family, color = swifty_colors$morado, face = "bold", size = base_size + 3
      ),
      plot.subtitle     = ggplot2::element_text(
        family = base_family, color = swifty_colors$gris, size = base_size
      ),
      axis.title.x      = ggplot2::element_text(family = base_family, color = swifty_colors$negro, face = "bold"),
      axis.title.y      = ggplot2::element_text(family = base_family, color = swifty_colors$negro, face = "bold"),
      axis.text         = ggplot2::element_text(family = base_family, color = swifty_colors$negro),
      legend.position   = "right",
      legend.title      = ggplot2::element_text(family = base_family, face = "bold", color = swifty_colors$morado)
    )
}
eras_theme <- theme_swifty

# Normalizamos los nombres de era para asegurar match con paleta
indicador_era <- indicador_era %>%
  dplyr::mutate(
    era_norm = dplyr::case_when(
      tolower(era) == "folklore" ~ "Folklore",
      tolower(era) == "evermore" ~ "Evermore",
      tolower(era) == "fearless" ~ "Fearless",
      TRUE ~ era
    )
  )

# Construye tonos por era (usando los nombres normalizados presentes)
eras_presentes <- unique(indicador_era$era_norm)

# Paleta corregida: Evermore = beige, Folklore = gris, Fearless = dorado (aseg√∫rate de tener esta en tu swifty_era_pal)
fill_colors <- c(
  Lover      = swifty_era_pal$Lover[1],
  Reputation = swifty_era_pal$Reputation[1],
  Red        = swifty_era_pal$Red[1],
  "1989"     = swifty_era_pal[["1989"]][1],
  Midnights  = swifty_era_pal$Midnights[1],
  Folklore   = swifty_era_pal$Folklore[1],  # gris
  Evermore   = swifty_era_pal$Evermore[1],  # beige
  TTPD       = swifty_era_pal$TTPD[1],
  Fearless   = swifty_era_pal$Fearless[1],  # dorado
  "Speak Now"= swifty_era_pal[["Speak Now"]][1]
)
# Filtra solo las eras presentes (importante para evitar NAs)
fill_colors <- fill_colors[eras_presentes]

# Colores de borde (segundo tono) y de etiqueta (tercer tono)
border_colors <- c(
  Lover      = swifty_era_pal$Lover[2],
  Reputation = swifty_era_pal$Reputation[2],
  Red        = swifty_era_pal$Red[2],
  "1989"     = swifty_era_pal[["1989"]][2],
  Midnights  = swifty_era_pal$Midnights[2],
  Folklore   = swifty_era_pal$Folklore[2],  # gris medio
  Evermore   = swifty_era_pal$Evermore[2],  # beige medio
  TTPD       = swifty_era_pal$TTPD[2],
  Fearless   = swifty_era_pal$Fearless[2],  # dorado medio
  "Speak Now"= swifty_era_pal[["Speak Now"]][2]
)
border_colors <- border_colors[eras_presentes]

label_colors <- c(
  Lover      = swifty_era_pal$Lover[3],
  Reputation = swifty_era_pal$Reputation[3],
  Red        = swifty_era_pal$Red[3],
  "1989"     = swifty_era_pal[["1989"]][3],
  Midnights  = swifty_era_pal$Midnights[3],
  Folklore   = swifty_era_pal$Folklore[3],  # gris claro
  Evermore   = swifty_era_pal$Evermore[3],  # beige claro
  TTPD       = swifty_era_pal$TTPD[3],
  Fearless   = swifty_era_pal$Fearless[3],  # dorado claro
  "Speak Now"= swifty_era_pal[["Speak Now"]][3]
)
label_colors <- label_colors[eras_presentes]



# Comenzamos con nuestro an√°lisis

## Con los nombres de la canciones definiremos las eras, haciendo un etiquetado de cada fila de la base para indicar a qu√© ‚Äúera‚Äù (√°lbum) pertenece cada track. Esto nos va a permitir, agrupar y comparar el indicador PCA por era del tour m√°s adelante.

df <- df %>%
  mutate(era = case_when(
    # Lover
    track_name %in% c("Miss Americana & The Heartbreak Prince","Cruel Summer","The Man", "You Need To Calm Down","Lover","The Archer") ~ "Lover",
    # Fearless (Taylor's Version)
    str_detect(track_name, regex("^Fearless", ignore_case = TRUE)) |
      str_detect(track_name, "You Belong With Me") |
      str_detect(track_name, "Love Story") ~ "Fearless",
    # Red (Taylor's Version)
    track_name %in% c("22 (Taylor's Version)",
                      "We Are Never Ever Getting Back Together (Taylor's Version)",
                      "I Knew You Were Trouble (Taylor's Version)",
                      "All Too Well (10 Minute Version) (Taylor's Version) (From The Vault)") ~ "Red",
    # Reputation
    track_name %in% c("...Ready For It?","Delicate","Don‚Äôt Blame Me","Look What You Made Me Do") ~ "Reputation",
    # folklore
    track_name %in% c("cardigan","betty","my tears ricochet", "august", "illicit affairs") ~ "folklore",
    # evermore
    track_name %in% c("champagne problems","marjorie","willow") ~ "evermore",
    # 1989 (Taylor's Version)
    track_name %in% c("Style (Taylor's Version)","Blank Space (Taylor's Version)",
                      "Shake It Off (Taylor's Version)","Wildest Dreams (Taylor's Version)",
                      "Bad Blood (Taylor's Version)") ~ "1989",
    # Speak Now (Taylor's Version)
    str_detect(track_name, "Enchanted") ~ "Speak Now",
    # The Tortured Poets Department (TTPD)
    track_name %in% c("But Daddy I Love Him","So High School","Who‚Äôs Afraid of Little Old Me?",
                      "Down Bad","Fortnight (feat. Post Malone)",
                      "The Smallest Man Who Ever Lived","I Can Do It With a Broken Heart") ~ "TTPD",
    # Midnights
    track_name %in% c("Lavender Haze","Anti-Hero","Midnight Rain","Vigilante Shit",
                      "Bejeweled","Mastermind","Karma") ~ "Midnights",
    TRUE ~ NA_character_
    ))

## Revisando... para ver si todo est√° perfectly fine
## ¬øCu√°les son las canciones sin era? (debe ser 0)
df %>% filter(is.na(era)) %>% distinct(track_name)

## Conteo por era
df %>% count(era, sort = TRUE)


# Seleccionaremos las variables y escala para que funcione nuestro PCA. 
## Vamos a seleccionar las variables num√©ricas que van a entrar al PCA (en formato num√©rico, sin NA), despu√©s deber√≠amos filtrar outliers obvios (pero el principal era duraci√≥n y no queremos borrar All too well) y luego vamos a estandarizar/escalar cada variable para que todas tengan media 0 y desv√≠o est√°ndar 1.

## Esta base tiene variables ac√∫sticas, as√≠ que utilizaremos esa informaci√≥n y tambi√©n otras como duraci√≥n y popularidad.
## En este caso, haremos la escala sin reducir por duraci√≥n porque a pesar de que "All too well" se sale del rango normal o promedio porque es una parte importante del show. Veremos como se refleja esto despu√©s...
## Escalamos con mutate(across(..., scale)), lo que asegura que todas las variables tengan media 0 y sd 1.

variables <- c("danceability","energy","valence","tempo","loudness",
          "speechiness","acousticness","instrumentalness","liveness",
          "duration_ms","popularity")

df_variables <- df %>%
  drop_na(all_of(variables)) %>%
  mutate(across(all_of(variables), scale))

#Revisando...
summary(df[variables])        # antes
summary(df_variables[variables])  # despu√©s (medias ~0, sd ~1)


# Comenzamos la matriz para PCA (ya escalada en df_variables)
X <- df_variables %>% dplyr::select(dplyr::all_of(variables)) %>% as.matrix()

# Ejecutando PCA
## Como las variables ya est√°n escaladas (z-score), no centramos/escalamos de nuevo
pca <- prcomp(X, center = FALSE, scale. = FALSE)

## Resumen r√°pido del PCA (varianza explicada por cada componente)
summary(pca)

# Proporci√≥n de varianza explicada por cada PC
var_exp <- pca$sdev^2 / sum(pca$sdev^2)
acum_var <- cumsum(var_exp)

# Comenzamos la representaci√≥n visual

# Scree Plot base R
plot(var_exp, type = "b", pch = 19, col = eras_color,
     xlab = "Componente principal",
     ylab = "Proporci√≥n de varianza explicada",
     main = "Scree Plot (PCA)",
     xaxt = "n")
axis(1, at = seq_along(var_exp), labels = paste0("PC", seq_along(var_exp)))
abline(h = 0.1, col = eras_grid, lty = 2)

## A√±adimos anotaciones con % de varianza
text(x = seq_along(var_exp), y = var_exp + 0.02,
     labels = paste0(round(var_exp * 100, 1), "%"),
     col = eras_color, cex = 0.8)

## A√±adimos l√≠nea acumulada
lines(acum_var, type = "b", col = "#FF69B4", lty = 3)
text(length(acum_var), tail(acum_var, 1) - 0.05,
     paste("Acumulada:", round(tail(acum_var, 1) * 100, 1), "%"),
     col = "#FF69B4", cex = 0.8)

# Versi√≥n ggplot 
library(ggplot2)
df_varpc <- tibble::tibble(
  PC = paste0("PC", seq_along(var_exp)),
  VarExp = var_exp
)

ggplot(df_varpc, aes(x = PC, y = VarExp, group = 1)) +
  geom_point(size = 2) +
  geom_line() +
  # Etiquetas de porcentaje sobre cada punto
  geom_text(aes(label = scales::percent(VarExp, accuracy = 0.1)),
            vjust = -0.8, size = 2.3) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  labs(title = "Scree Plot (PCA)",
       x = "Componente principal",
       y = "Varianza explicada") +
  eras_theme()

# Varianza acumulada
acum_var <- cumsum(var_exp)

# Tabla r√°pida para consola
data.frame(PC = paste0("PC", seq_along(var_exp)),
           VarExp = round(var_exp, 4),
           AcumVar = round(acum_var, 4))

# Cargas (qu√© pesa en cada componente)
loadings <- pca$rotation

# Ver las cargas de los 3 primeros PCs (redondeadas)
print(round(loadings[, 1:3], 3))

# Variables que m√°s pesan en PC1 (para nombrarlo)
sort(loadings[,1], decreasing = TRUE)

# Variables que m√°s pesan en PC2
sort(loadings[,2], decreasing = TRUE)

#¬øQu√© son estos resultados?
##Si vemos cargas altas positivas en energy, loudness, tempo y negativas en acousticness ‚Üí PC1 ‚âà ‚ÄúIntensidad/Energ√≠a‚Äù. Y Si danceability y valence cargan alto en PC2 ‚Üí PC2 ‚âà ‚ÄúBailabilidad/Positividad‚Äù. Speechiness e instrumentalness suelen matizar (m√°s hablado vs. m√°s instrumental).

# Dej√©moslo en una tablita
knitr::kable(round(loadings[,1:3], 3), caption = "Cargas de las variables en PC1‚ÄìPC3")

# Scores (coordenadas de cada canci√≥n en los PCs)
scores <- as.data.frame(pca$x) %>% dplyr::select(PC1, PC2, PC3)

# Unimos los scores al df (para tener track_name y metadatos)
df_scores <- df_variables %>%
  dplyr::bind_cols(scores) %>%
  dplyr::rename(indicador_pc1 = PC1, indicador_pc2 = PC2)

# Normalizamos el indicador principal (PC1) a escala 0‚Äì100 (para comunicarlo mejor)
rng <- range(df_scores$indicador_pc1, na.rm = TRUE)
df_scores <- df_scores %>%
  dplyr::mutate(indicador_0_100 = 100 * (indicador_pc1 - rng[1]) / (rng[2] - rng[1]))

## Ya que incluimos popularity dentro de las variables del PCA, el indicador mezcla perfil ac√∫stico con recepci√≥n del p√∫blico.

# Top 10 canciones (mayor intensidad/energ√≠a seg√∫n PC1)
top10 <- df_scores %>%
  dplyr::arrange(dplyr::desc(indicador_0_100)) %>%
  dplyr::select(track_name, indicador_0_100) %>%
  head(10)

knitr::kable(top10, caption = "Top 10 canciones por indicador (PC1 ‚Üí 0‚Äì100)")

### El PC1 explica r scales::percent(var_exp[1]) y el PC2 r scales::percent(var_exp[2]) de la varianza total; juntos, los dos primeros explican r scales::percent(sum(var_exp[1:2])).

# Promedio del indicador por era
indicador_era <- df_scores %>%
  dplyr::filter(!is.na(era)) %>%
  dplyr::group_by(era) %>%
  dplyr::summarise(indicador_era = mean(indicador_0_100),
                   n_canciones = n(),
                   .groups = "drop") %>%
  dplyr::arrange(dplyr::desc(indicador_era))

knitr::kable(indicador_era, caption = "Indicador promedio por era (PC1 ‚Üí 0‚Äì100)")

# Barras por era
ggplot(indicador_era,
       aes(x = reorder(era_norm, indicador_era), y = indicador_era)) +
  geom_col(aes(fill = era_norm), linewidth = 0.0, color = NA) +
  geom_col(fill = NA, color = NA) +
  geom_col(aes(y = indicador_era),
           fill = NA,
           color = border_colors[indicador_era$era_norm],
           linewidth = 0.6) +
  geom_text(aes(label = round(indicador_era, 1)),
            hjust = -0.1,
            size = 3.5,
            color = label_colors[indicador_era$era_norm]) +
  coord_flip() +
  scale_fill_manual(values = fill_colors) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.08))) +
  labs(
    title = "Indicador PCA (PC1) promedio por Era",
    subtitle = "Evermore (beige), Folklore (gris), Fearless (dorado). Tono 1 = relleno, Tono 2 = borde, Tono 3 = etiquetas",
    x = "Era",
    y = "Indicador 0‚Äì100"
  ) +
  eras_theme(base_family = "serif")
  guides(fill = "none")

# PCs y vectores de variables (diagn√≥stico r√°pido)
var_exp <- (pca$sdev^2) / sum(pca$sdev^2)
pc1_pct <- 100 * var_exp[1]
pc2_pct <- 100 * var_exp[2]
total12 <- pc1_pct + pc2_pct

## Construimos data para ggplot: scores (observaciones) y loadings (variables)
scores <- as.data.frame(pca$x[, 1:2]) %>%
  rename(PC1 = 1, PC2 = 2)

loadings <- as.data.frame(pca$rotation[, 1:2]) %>%
  rename(PC1 = 1, PC2 = 2) %>%
  mutate(var = rownames(pca$rotation))

arrow_scale <- 4
titulo    <- "Relaci√≥n entre observaciones y variables en el espacio PCA (PC1‚ÄìPC2)"
subtitulo <- sprintf("PC1 explica %.1f%% y PC2 %.1f%% (%.1f%% acumulado)", pc1_pct, pc2_pct, total12)

ggplot() +
  # Observaciones (scores)
  geom_point(data = scores, aes(x = PC1, y = PC2),
             color = "purple", alpha = 0.7, size = 2) +
  # Vectores de variables (loadings)
  geom_segment(data = loadings,
               aes(x = 0, y = 0, xend = PC1 * arrow_scale, yend = PC2 * arrow_scale),
               arrow = arrow(length = unit(0.08, "inches")),
               color = "pink", linewidth = 0.5) +
  geom_text(data = loadings,
            aes(x = PC1 * arrow_scale, y = PC2 * arrow_scale, label = var),
            color = "black", size = 3, vjust = -0.4) +
  labs(
    title = titulo,
    subtitle = subtitulo,
    x = sprintf("PC1 (%.1f%%)", pc1_pct),
    y = sprintf("PC2 (%.1f%%)", pc2_pct)
  ) +
  eras_theme(base_family = "serif")

### PC1 es alto en r paste(names(sort(loadings[,1], decreasing = TRUE)[1:3]), collapse = ", ") y bajo en r names(sort(loadings[,1], decreasing = FALSE)[1]); y lo interpretamos como ‚ÄòIntensidad/Energ√≠a‚Äô. El PC2 es alto en r paste(names(sort(loadings[,2], decreasing = TRUE)[1:3]), collapse = ", "), interpretado como ‚ÄòBailabilidad/Positividad‚Äô.‚Äù

### Definimos el indicador principal como el score en PC1, normalizado a 0‚Äì100 para facilitar la lectura. Quedando el ranking de canciones y agregaci√≥n por era.

### Las variables de entrada se estandarizaron (media 0, sd 1). No se filtr√≥ duraci√≥n (se mantuvo ‚ÄòAll Too Well (10 Minute Version)‚Äô por su relevancia en el show).


# --- Heatmap de loadings PC1‚ÄìPC3 ---
## Tomamos las cargas y pasamos a formato largo
loadings <- pca$rotation
loadings_df <- loadings[, 1:3] %>%
  as.data.frame() %>%
  tibble::rownames_to_column(var = "variable") %>%
  tidyr::pivot_longer(
    cols = dplyr::starts_with("PC"),
    names_to = "PC",
    values_to = "loading"
  )

# Ordenamos variables por la magnitud de su contribuci√≥n en PC1 (para visualizarlas)
vars_order <- loadings_df %>%
  dplyr::filter(PC == "PC1") %>%
  dplyr::arrange(dplyr::desc(loading)) %>%
  dplyr::pull(variable)

# Etiquetas descriptivas para las PCs
loadings_df <- loadings_df %>%
  dplyr::mutate(
    variable = factor(variable, levels = vars_order),
    PC = factor(
      PC,
      levels = c("PC1", "PC2", "PC3"),
      labels = c(
        "PC1 = Intensidad/Energ√≠a",
        "PC2 = Bailabilidad/Positividad",
        "PC3 = Textura/Ac√∫stico‚ÄìVocal"
      )
    )
  )

# Heatmap
ggplot(loadings_df, aes(x = PC, y = variable, fill = loading)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(
    low = "#C7A8CB", mid = "white", high = "#B5E5F8",
    midpoint = 0,
    limits = c(min(loadings_df$loading), max(loadings_df$loading)),
    name = "Carga"
  ) +
  labs(
    title = "Heatmap de cargas (loadings) en PC1‚ÄìPC3",
    x = "Componente principal",
    y = "Variable"
  ) +
  eras_theme() +
  theme(axis.text.y = element_text(size = 10))
  
  

# Seleccionamos top N por magnitud en PC1 
N <- 12
df_scores <- df_scores %>%
  mutate(abs_pc1 = abs(indicador_pc1))

df_labels <- df_scores %>%
  arrange(desc(abs_pc1)) %>%
  slice(1:N)

ggplot(df_scores, aes(x = indicador_pc1, y = indicador_pc2)) +
  geom_hline(yintercept = 0, color = "gray80") +
  geom_vline(xintercept = 0, color = "gray80") +
  geom_point(alpha = 0.6, color = "#7B68EE", size = 2) +
  geom_point(data = df_labels, color = "#FF7F50", size = 2.5) +
  geom_text_repel(data = df_labels,
                  aes(label = track_name),
                  size = 3.2,
                  box.padding = 0.4,
                  point.padding = 0.2,
                  max.overlaps = 100,
                  seed = 123,
                  min.segment.length = 0) +
  labs(title = "Mapa PC1 Intensidad/Energ√≠a vs PC2 	
Bailabilidad/Positividad de canciones del Eras Tour",
       x = "PC1 (Intensidad/Energ√≠a, seg√∫n cargas)",
       y = "PC2 (Bailabilidad/Positividad, seg√∫n cargas)") +
  eras_theme()


#üìÑ Conclusiones

## Resumen del PCA:
### El PC1 Intensidad/Energ√≠a explica r scales::percent(var_exp[1]) y el PC2 Bailabilidad/Positividad r scales::percent(var_exp[2]) de la varianza; en conjunto suman r scales::percent(sum(var_exp[1:2])).
PC1 ‚Äî Intensidad/Energ√≠a: altas cargas en energy, loudness, tempo y bajas en acousticness.
PC2 ‚Äî Bailabilidad/Positividad: dominado por danceability y valence.
PC3 ‚Äî Textura/Ac√∫stico‚ÄìVocal (o el nombre que definiste): matizado por speechiness, instrumentalness, liveness.

### Indicador compuesto:
Definimos el indicador principal como el score en PC1, normalizado a 0‚Äì100. Presentamos el ranking de canciones y la agregaci√≥n por era.

### Decisiones metodol√≥gicas:
(i) Est√°ndar z‚Äìscore en features; (ii) No se filtr√≥ la duraci√≥n por la relevancia de ‚ÄúAll Too Well (10 Minute Version)‚Äù; (iii) La inclusi√≥n/exclusi√≥n de popularity dentro del PCA se documenta.

### Limitaciones:
Los cambios de setlist y versiones (Taylor‚Äôs Version) pueden afectar comparabilidad si se ampl√≠a la base.
Las representaciones no son tan alineadas con la l√≠nea gr√°fica, pero se intent√≥ lo m√°s que se pudo.
Agradezco nuevamente a https://www.kaggle.com/datasets/yukawithdata/taylor-swift-the-eras-tour-official-setlist-data por poner a disposici√≥n esta incre√≠ble base de datos.
Cierro este curso muy agradecida y entusiasta por lo mucho aprendido, si bien esta actividad tuvo una dificultad mayor, pude usar una base que me interesa y eso me permiti√≥ trabajar con m√°s determinaci√≥n en llegar a mejores resultados (a pesar de que pas√© m√°s tiempo intentando arreglar los colores de las barras por era que en el resto). Gracias por leer!

